#!/bin/bash
# Checked by https://www.shellcheck.net/


# Constants
MYSQL_USER=root
MYSQL_DATA_DIR=/var/lib/mysql


# Functions
prompt_yn() {	# params: message
	msg="$*"
	if [ -z "$msg" ]; then
		msg='Are you sure?'
	fi
	result=-1
	while true; do
		read -rp "$msg [yes/no] " result
		case $result in
			[Yy]* ) result=0; break;;
			[Nn]* ) result=1; break;;
			*) echo "Please answer yes or no.";;
		esac
	done
	return $result
}
warn() {	# params: message
    echo "$@" >&2
}
die() {	# params: exit code; message
    rc="$1"
    shift
    warn "$@"
    exit "$rc"
}
usage() {
	msg="$*"
	this=$(basename "$0")
	if [ -n "$msg" ]; then
		warn "$this: ERROR: $msg"
	fi
	warn "Usage: $this [-dk]"
	warn '	Arguments:'
	warn "		-c or --continue: Continue after failure. This restores all previously made *.sql.gz files too."
	warn "		-d or --dry-run: Do not drop databases, remove files from $MYSQL_DATA_DIR, or restore databases."
	warn '		-h or --help: Show this.'
	if [ -n "$msg" ]; then
		exit 1
	fi
	exit 0
}


# Command line arguments
while :
do
	case "$1" in
		-c) CONTINUE=1;;
		--continue) CONTINUE=1;;
		-d) DRYRUN=1;;
		--dry-run) DRYRUN=1;;
		-h) usage;;
		--help) usage;;
		-t) TEST=1;;	# secret option
		#-o) shift; o="$1";;
		#--) shift; break;;
		-*) usage "bad argument $1";;
		*) break;;
	esac
	shift
done
if [ -n "$DRYRUN" ]; then
	echo '*** DRY RUN ***'
fi


# Make sure this script is running as root as sudo is not installed by default on Debian.
if [ "$(id -u)" -ne 0 ]; then
	die 1 'This script must be executed as root!';
fi


# Check that $MYSQL_DATA_DIR and the ibdata1 file exist.
if [ ! -d "$MYSQL_DATA_DIR" ]; then
	die 1 "Directory $MYSQL_DATA_DIR not found!"
fi
IBDATA1_FILE="$MYSQL_DATA_DIR/ibdata1"
if [ ! -f "$IBDATA1_FILE" ]; then
	die 1 "$IBDATA1_FILE not found!"
fi


# Check that required binaries are available.
if [ -z "$(command -v mysql)" ]; then
	die $? 'MySQL client (mysql) is not installed!'
fi
if [ -z "$(command -v mysqldump)" ]; then
	die $? 'mysqldump not found!'
fi
GZIP="$(command -v pigz)"
if [ -z "$GZIP" ]; then
	GZIP="$(command -v gzip)"
	if [ -z "$GZIP" ]; then
		die $? 'gzip not found!'
	fi
fi


# This line is the only bash dependency:
if [ "$(basename "$SHELL")" = 'bash' ]; then
	set -o pipefail
fi


# Make sure mysqld is running
if [ -z "$(pidof mysqld)" ]; then
	echo "Starting mysql service."
	service mysql start || die 1 "Failed to start mysql: $?"
else
	echo 'Found active mysql service.'
fi


# Attempt login (first by trying auth_socket authentication, then plain old password authentication)
MYSQL_PASS=
if mysql -u"$MYSQL_USER" -e ';' 2>/dev/null; then
	# password is ignored for auth_socket authentication, but must be at least 1 character if the -p argument is given
	MYSQL_PASS='dummy'
else
	read -rsp "Enter the MySQL $MYSQL_USER password: " MYSQL_PASS
	if ! mysql -u"$MYSQL_USER" -p"$MYSQL_PASS" -e ';' 2> /dev/null; then
		echo 'Invalid password.'
		exit 1
	fi
fi


SIZE_BEFORE=$(du -h "$IBDATA1_FILE" | cut -f1)
echo "Current size of $IBDATA1_FILE: $SIZE_BEFORE"


# List databases
#DATABASES=$( mysql -u"$MYSQL_USER" -p"$MYSQL_PASS" --silent -e 'SHOW DATABASES' | grep -Ev '^(information_schema|mysql|performance_schema)$' )
if ! DATABASES=$(mysql -u"$MYSQL_USER" -p"$MYSQL_PASS" --silent -e 'SHOW DATABASES'); then
	die $? 'SHOW DATABASES command failed!'
fi
DATABASES=$( echo "$DATABASES" | grep -Ev '^(information_schema|mysql|performance_schema)$' );
if [ ! $? ]; then
	die $? 'Failed to grep database list!'
fi
echo "Databases to backup into the current directory ($(pwd)) and then drop:"
for DATABASE in $DATABASES; do
	echo "	$DATABASE"
done
if ! prompt_yn 'Do you really want to continue?'; then
	exit 0
fi


## Backup and drop databases
for DATABASE in $DATABASES; do
	FILE="$DATABASE.sql.gz"
	printf 'Backup %s to %s... ' "$DATABASE" "$FILE"
	if ! mysqldump --opt -u"$MYSQL_USER" -p"$MYSQL_PASS" --databases "$DATABASE" | "$GZIP" > "$FILE"; then
		die $? 'ERROR: mysqldump failed'
	fi
	if [ ! -f "$FILE" ]; then
		die 1 "ERROR: mysqldump indicated success, but $FILE is missing. Something went wrong!"
	fi
	echo "OK $(du -h "$FILE" | cut -f1)"

	# Only dump 1 database for testing:
	if [ -n "$DRYRUN" ] && [ -n "$TEST" ]; then
		echo 'Only dumping 1 database for testing.'
		break
	fi

done
# Drop databases last as mysqldump may refuse to dump those containing views referencing other already dropped databases.
for DATABASE in $DATABASES; do
	printf 'Drop %s... ' "$DATABASE"
	if [ -z "$DRYRUN" ]; then
		if ! mysql -u"$MYSQL_USER" -p"$MYSQL_PASS" -e "DROP DATABASE \`$DATABASE\`"; then
			die 1 "ERROR: failed to drop database $DATABASE"
		fi
		echo 'OK'
	else
		echo '(Skipped in DRY RUN)'
	fi
done


# Stop mysql; delete ib* files; start mysql
printf 'Stopping mysql service... '
if ! service mysql stop; then
	die $? 'ERROR: Failed to stop mysql service!'
fi
echo 'OK'
for x in "$MYSQL_DATA_DIR"/ibdata? "$MYSQL_DATA_DIR"/ib_logfile*; do
	if [ -f "$x" ]; then
		printf 'Remove %s (%s)... ' "$x" "$(du -h "$x" | cut -f1)"
		if [ -z "$DRYRUN" ]; then
			if ! rm -f "$x"; then
				die $? "ERROR: Failed to remove $x"
			fi
			echo 'OK'
		else
			echo '(Skipped in DRY RUN)'
		fi
	fi
done
printf 'Starting mysql service... '
if ! service mysql start; then
	die $? 'ERROR: Failed to start mysql service!'
fi
echo 'OK'

# Restoring
if [ -n "$CONTINUE" ]; then
	known_databases=''
	unknown_databases=''
	for file in *.sql.gz; do
		known=''
		database=$( echo "$file" | sed 's/\.sql\.gz$//' );
		#database=${file//.sql.gz/};
		for DATABASE in $DATABASES; do
			if [ "$database" = "$DATABASE" ]; then
				known_databases="$known_databases $database"
				known=1
				break
			fi
		done
		if [ -z "$known" ]; then
			unknown_databases="$unknown_databases $database"
		fi
	done;
	if [ -n "$unknown_databases" ]; then
		DATABASES=$( for x in $known_databases $unknown_databases; do echo "$x"; done | sort );
	else
		DATABASES=$( for x in $known_databases; do echo "$x"; done | sort );
	fi
	echo 'Databases to restore:'
	for DATABASE in $DATABASES; do
		echo "	$DATABASE"
	done
	if ! prompt_yn 'Do you really want to continue?'; then
		exit 0
	fi
fi
for DATABASE in $DATABASES; do
	FILE="$DATABASE.sql.gz"
	if [ -f "$FILE" ]; then
		printf 'Restore %s to database %s... ' "$FILE" "$DATABASE"
		if [ -z "$DRYRUN" ]; then
			if ! "$GZIP" -dc "$FILE" | mysql -u"$MYSQL_USER" -p"$MYSQL_PASS"; then
				die $? 'ERROR'
			fi
			echo 'OK'
			rm -f "$FILE"
		else
			echo '(Skipped in DRY RUN)'
		fi
	fi
done


echo "Size of $IBDATA1_FILE before shrinking: $SIZE_BEFORE"
SIZE_AFTER=$(du -h "$IBDATA1_FILE" | cut -f1)
echo "Size of $IBDATA1_FILE after shrinking: $SIZE_AFTER"
